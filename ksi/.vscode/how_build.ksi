
$how_build (
	max_depth# = 16
	def_cfg# = #{'platform:target' : 'win64:release'}
	
	`static
	magic = {%workspace_dir : ''}
	rules
	is_win
	perm = 0o777
)

&read_json path null (
	path #file_get_contents # => ret ?? (# `throw 'error: Unable to open "' % path % '"')
	ret #json_decode{%depth: $.max_depth#} => ret #is_not $map
	`then
		# `throw 'error: json file was not parsed "' % path % '"'
	`end
)

&read_json_opt path default (
	`try e (
		ret = path &read_json #
	) `catch (
		e.msg #replace [~^error\:~ , 'notice:'] #write_ln #
		ret = default
	)
)

&config_path path null (
	path = path #path_info #
	path.dirname => dir_config #file_stat # => stat #is_not $map
	`then
		# `throw 'error: Unable to get permissions on folder "' % dir_config % '"'
	`end
	$.perm = stat.mode & 0o777
	$.magic.workspace_dir = dir_config #replace [~[/\\][^/\\]+$~ , '']
)

&read_config path null (
	path &config_path #
	data = path &read_json_opt $.def_cfg#
	ret = {}
	$.def_cfg# `each key value (
		data #key_absent key || data[$key] #is_not $text
		`then
			# `echo
				'warning: config key "' key '" should have string value; So we use value "'
				value '" instead; Check file "' path '"' "\n"
			;
			ret[key] = value
		`else
			ret[key] = data[key]
		`end
	)
)

&deep data {%map %path} (
	map `each key value (
		data #is_not $map || data #key_absent value
		`then
			# `throw 'error: ' % key % ' "' % $value % '" was not configured in file "' % path % '"'
		`end
		data = data[value]
	)
	ret = data
)

&fix_path path null (
	ret = path #replace ['\\', '/']
)

&relative_path path base (
	path = path &fix_path #
	base = base &fix_path #
	pattern = '~^' % base% '/~' #as $regexp
	ret = path &replace [pattern, '']
)

&magic_rules magic null (
	ret = {}
	magic `each key value (
		ret[k = '${' % key % '}'] = [k, value]
	)
)

&each_rules each null (
	parts = each #path_info #
	each_rel = each &relative_path $.magic.workspace_dir
	parts_rel = each_rel #path_info #
	ret = {
		'${each.full}'					=> k : [k, each]
		'${each.full.no_extension}'		=> k : [k, parts.dirname % '/' % parts.filename]
		'${each.full.dirname}'			=> k : [k, parts.dirname]
		--
		'${each.rel}'					=> k : [k, each_rel]
		'${each.rel.no_extension}'		=> k : [k, parts_rel.dirname % '/' % parts.filename]
		'${each.rel.dirname}'			=> k : [k, parts_rel.dirname => dir == '' ? '.' : dir ;]
		--
		'${each.filename}'				=> k : [k, parts.basename]
		'${each.filename.no_extension}'	=> k : [k, parts.filename]
		'${each.extension}'				=> k : [k, parts.extension]
	}
)

&apply_rules rules text (
	ret = text #replace rules
	[ret, count] = ret #replace_special[ [~\$\{[^\}]*\}~ , ''] ]
	count
	`then
		# `echo 'warning: Found wrong substitutions: ', count, "; Supported:\n", rules #keys # : "\n", "\n";
	`end
)

&run_task_list data path (
	data #is_not $map || data #empty #
	`then
		# `throw 'error: Tasks should be non-empty assoc array in file "' % $path % '"'
	`end
	$.rules = $.magic &magic_rules #
	data `each key task (
		task &run_task[key, path]
	)
)

&run_task task {%task_key %path} (
	task #is_not $map
	`then
		# `throw 'warning: Task "' % task_key % '" should be assoc array in file "' % path % '"'
	`end
	task #key_absent (k='command') || (cmd = task[k]) is_not $text
	`then
		# `throw 'warning: Task "' % task_key %
		'" should contain "command" key with string value in file "' % path % '"'
	`end
	task #key_absent (k='args') || (args = task[k]) #is_not $array
	`then
		# `throw 'warning: Task "' % $task_key %
		'" should contain "args" key with array value in file "' % $path % '"'
	`end
	# `echo 'Perform "', task_key, '" task:', "\n";
	cmd = $.rules &apply_rules cmd
	task #has_key (k='each_plain') && (each_list = task[k]) #is $array
	`then
		each_list `each key each (
			rules = $.rules #join {'${each}' : each}
			result = task &impl_run_task[task_key, cmd, args, rules]
		)
	`else
		task #hask_key (k='each') && (each_list = task[k]) #is $array
	`then
		each_list `each key each (
			each = $.rules &apply_rules each
			rules = $.rules #join (each &each_rules #)
			result = task &impl_run_task[task_key, cmd, args, rules]
		)
	`else
		result = task &impl_run_task[task_key, cmd, args, $.rules]
	`end
)

&impl_run_task task {%task_key %cmd %args %rules} (
	task #has_key (k='maybe_create_dir') && (maybe_dir = task[k]) #is $text
	`then
		maybe_dir = rules &apply_rules maybe_dir
		maybe_dir #fule_is_dir #
		`otherwise
			maybe_dir #file_is_regular #
			`then
				# `throw 'error: Requested option "' % k % '" in task "' % task_key %
				'" but it is regular file "' % maybe_dir % '"'
			`end
			maybe_dir #file_make_dir[$.perm, #1]
			`otherwise
				# `throw  'error: Requested option "' % k .'" in task "' % task_key %
				'" but unable to create "' % maybe_dir % '"'
			`end
		`end
	`end
	--
	args = rules &apply_rules args
	cmd &run_command args => ret
	`then
		# `echo 'notice: Result = ', ret, "\n";
		ret #exit #
	`end
)

&run_command cmd args (
	cmd `echo args : ' ', "\n";
	cmd = cmd #escape_shell_cmd #
	$.is_win `then cmd = '"' % cmd % '"' `end
	args = args #map_fn #escape_shell_arg& #implode ' '
	cmd %= ' ' % args
	ret = cmd #pass_thru #
)

`plain

$how_build.is_win = ~^win~i #match OS# #as $bool

`try e (
	$srv.args #count # < 5 || $srv.args.1 != '-json' || $srv.args.3 != '-config'
	`then
		# `throw 'usage: how_build.php -json <path> -config <path>'
	`end
	config = $srv.args.4 &read_config #
	data = ($srv.args.2 => json_path) &read_json #
	data = data &deep[config, json_path]
	data &run_task_list json_path
) `catch (
	e.msg #write_ln #
	1 #exit #
)
